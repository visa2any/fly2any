export const dynamic = 'force-dynamic';

import { NextResponse } from 'next/server'
import { auth } from '@/lib/auth'
import { getPrismaClient } from '@/lib/prisma'

const prisma = getPrismaClient()

/**
 * GET /api/admin/referrals/stats
 * Get comprehensive referral program statistics for admin
 */
export async function GET() {
  try {
    const session = await auth()

    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Check if user is admin
    const adminUser = await prisma.adminUser.findUnique({
      where: { userId: session.user.id },
    })

    if (!adminUser) {
      return NextResponse.json({ error: 'Admin access required' }, { status: 403 })
    }

    // Get overall stats
    const totalReferrals = await prisma.referralNetworkRelationship.count()

    const activeReferrers = await prisma.user.count({
      where: {
        directReferralsCount: { gt: 0 },
      },
    })

    const pointsStats = await prisma.user.aggregate({
      _sum: {
        fly2anyPoints: true,
        fly2anyPointsLocked: true,
        fly2anyPointsLifetime: true,
        fly2anyPointsRedeemed: true,
      },
    })

    const revenueStats = await prisma.referralNetworkRelationship.aggregate({
      _sum: {
        totalRevenue: true,
      },
    })

    const stats = {
      totalReferrals,
      activeReferrers,
      totalPointsAwarded: pointsStats._sum.fly2anyPointsLifetime || 0,
      totalPointsLocked: pointsStats._sum.fly2anyPointsLocked || 0,
      totalPointsRedeemed: pointsStats._sum.fly2anyPointsRedeemed || 0,
      conversionRate: totalReferrals > 0 ? (activeReferrers / totalReferrals) * 100 : 0,
      totalRevenue: revenueStats._sum.totalRevenue || 0,
    }

    // Get top referrers (by network size and points)
    const topReferrers = await prisma.user.findMany({
      where: {
        directReferralsCount: { gt: 0 },
      },
      select: {
        id: true,
        name: true,
        email: true,
        referralCode: true,
        directReferralsCount: true,
        totalNetworkSize: true,
        fly2anyPoints: true,
        fly2anyPointsLocked: true,
        fly2anyPointsLifetime: true,
      },
      orderBy: [
        { fly2anyPointsLifetime: 'desc' },
        { totalNetworkSize: 'desc' },
      ],
      take: 20,
    })

    // Calculate revenue generated by each referrer
    const topReferrersWithRevenue = await Promise.all(
      topReferrers.map(async (referrer) => {
        const revenueData = await prisma.referralNetworkRelationship.aggregate({
          where: { referrerId: referrer.id },
          _sum: { totalRevenue: true },
        })

        return {
          ...referrer,
          totalRevenue: revenueData._sum.totalRevenue || 0,
        }
      })
    )

    // Get recent activity
    const recentSignupsQuery: any = {
      where: {
        level: 1, // Only direct referrals for signups
      },
      orderBy: { signupCompletedAt: 'desc' },
      take: 10,
      include: {
        referrer: {
          select: { name: true, email: true },
        },
        referee: {
          select: { name: true, email: true },
        },
      },
    }
    const recentSignups = await prisma.referralNetworkRelationship.findMany(recentSignupsQuery)

    const recentTransactionsQuery: any = {
      orderBy: { createdAt: 'desc' },
      take: 10,
      include: {
        earner: {
          select: { name: true, email: true },
        },
        customer: {
          select: { name: true, email: true },
        },
      },
    }
    const recentTransactions = await prisma.referralPointsTransaction.findMany(recentTransactionsQuery)

    // Combine and format recent activity
    const recentActivity = [
      ...recentSignups.map((signup: any) => ({
        id: signup.id,
        type: 'signup' as const,
        referrerName: signup.referrer.name || signup.referrer.email,
        referreeName: signup.referee.name || signup.referee.email,
        points: 0,
        createdAt: signup.signupCompletedAt?.toISOString() || signup.createdAt.toISOString(),
      })),
      ...recentTransactions.map((tx: any) => ({
        id: tx.id,
        type: tx.status === 'unlocked' ? ('unlock' as const) : ('booking' as const),
        referrerName: tx.earner.name || tx.earner.email,
        referreeName: tx.customer.name || tx.customer.email,
        points: tx.pointsAwarded,
        amount: tx.bookingAmount,
        createdAt: tx.createdAt.toISOString(),
      })),
    ]
      .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
      .slice(0, 15)

    return NextResponse.json({
      success: true,
      data: {
        stats,
        topReferrers: topReferrersWithRevenue,
        recentActivity,
      },
    })
  } catch (error) {
    console.error('Error fetching referral stats:', error)
    return NextResponse.json(
      { error: 'Failed to fetch referral stats' },
      { status: 500 }
    )
  }
}
